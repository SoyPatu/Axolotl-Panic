<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AXOLOTL PANIC - DELUXE EDITION</title>
  <style>
    :root {
      --pink: #ee4cb7;
      --cyan: #6be5f6;
      --yellow: #f9f86a;
      --purple: #d8b4ff;
      --light-pink: #ffe4f5;
      --light-purple: #e6d6ff;
      --light-yellow: #fff9c4;
      --gray: #bbb;
      --dark-gray: #777;
      --blue: #4fc3f7;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }

    body {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: white;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .screen {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      transition: opacity 0.6s ease;
      pointer-events: none;
    }

    .screen.active {
      opacity: 1;
      pointer-events: all;
    }

    h1 {
      font-size: 3.5rem;
      color: var(--pink);
      text-shadow: 0 0 10px var(--cyan);
      margin-bottom: 2rem;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    button {
      background: var(--cyan);
      color: #000;
      border: none;
      padding: 1rem 2rem;
      margin: 0.8rem;
      font-size: 1.4rem;
      border-radius: 15px;
      cursor: pointer;
      box-shadow: 0 6px 0 #0095c7;
      transition: all 0.2s;
      min-width: 220px;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 0 #0095c7;
    }

    button:active {
      transform: translateY(3px);
      box-shadow: 0 2px 0 #0095c7;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 6px 0 #666;
    }

    .btn-pink { background: var(--pink); box-shadow: 0 6px 0 #c2185b; }
    .btn-yellow { background: var(--yellow); color: #000; box-shadow: 0 6px 0 #f9a825; }
    .btn-purple { background: var(--purple); box-shadow: 0 6px 0 #9c27b0; }

    /* MENU */
    #menu-screen button {
      font-size: 1.6rem;
      padding: 1.2rem 2.5rem;
    }

    /* GAMEPLAY */
    #game-screen {
      padding: 1rem;
      justify-content: flex-start;
      overflow-y: auto;
    }

    .exit-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: #ff4444;
      color: white;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      box-shadow: 0 4px 0 #c00;
    }

    .players-info {
      display: flex;
      justify-content: space-around;
      width: 100%;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    .player-box {
      background: var(--light-purple);
      padding: 1rem;
      border-radius: 15px;
      width: 22%;
      min-width: 180px;
      text-align: center;
      border: 4px solid transparent;
      transition: all 0.3s;
    }

    .player-box.human { background: var(--light-pink); }
    .player-box.active { border: 4px solid var(--pink); transform: scale(1.05); }

    .player-box h3 { color: var(--blue); margin-bottom: 0.5rem; }
    .player-box p { margin: 0.3rem 0; font-size: 0.9rem; }

    .turn-indicator {
      font-size: 2rem;
      color: var(--cyan);
      margin: 1rem 0;
      text-shadow: 0 0 8px var(--blue);
    }

    .turn-indicator span {
      color: var(--blue);
      font-weight: bold;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
    }

    .stored-cards {
      background: var(--light-yellow);
      padding: 1rem;
      border-radius: 15px;
      width: 90%;
      max-width: 800px;
      margin: 1rem auto;
      min-height: 80px;
    }

    .stored-cards h3 {
      color: #000;
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .card-tag {
      display: inline-block;
      background: var(--cyan);
      color: #000;
      padding: 0.5rem 1rem;
      margin: 0.3rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9rem;
      box-shadow: 0 3px 0 #0095c7;
      transition: all 0.2s;
    }

    .card-tag:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 0 #0095c7;
    }

    .tokens-area {
      margin: 1.5rem 0;
      text-align: center;
    }

    .tokens-area h3 {
      margin-bottom: 0.8rem;
      color: var(--yellow);
    }

    .tokens {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .token {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--gray);
      border: 3px solid var(--dark-gray);
      transition: all 0.3s;
    }

    .token.revealed.pink { background: var(--pink); border-color: #c2185b; }
    .token.revealed.brown { background: #8d6e63; border-color: #5d4037; }
    .token.revealed.yellow { background: var(--yellow); border-color: #f9a825; }

    .token.removed {
      opacity: 0;
      transform: scale(0);
    }

    .message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 1.5rem 2.5rem;
      border-radius: 20px;
      font-size: 1.4rem;
      text-align: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s;
      border: 3px solid var(--cyan);
      box-shadow: 0 0 20px var(--cyan);
    }

    .message.show {
      opacity: 1;
      pointer-events: all;
    }

    /* MODALS */
    .modal {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s;
    }

    .modal.active {
      opacity: 1;
      pointer-events: all;
    }

    .modal-content {
      background: white;
      color: #000;
      padding: 2rem;
      border-radius: 20px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 0 30px var(--cyan);
      border: 4px solid var(--pink);
    }

    .modal h2 {
      text-align: center;
      color: var(--pink);
      margin-bottom: 1rem;
    }

    .shop-item, .fish-token {
      background: #f0f0f0;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .fish-token {
      cursor: pointer;
      transition: all 0.2s;
    }

    .fish-token.selected {
      border: 3px solid var(--blue);
      background: var(--light-yellow);
    }

    .modal-actions {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    /* RANKING */
    #ranking-screen {
      text-align: center;
    }

    .ranking-list {
      margin: 2rem 0;
      font-size: 1.5rem;
    }

    .ranking-list div {
      background: rgba(255,255,255,0.1);
      margin: 0.8rem auto;
      padding: 1rem;
      border-radius: 15px;
      width: 70%;
      max-width: 500px;
    }

    .winner {
      color: var(--yellow) !important;
      font-size: 1.8rem !important;
      animation: pulse 1.5s infinite;
    }

    /* TUTORIAL & CREDITS */
    .text-content {
      background: rgba(255,255,255,0.1);
      padding: 2rem;
      border-radius: 15px;
      margin: 1rem;
      max-width: 800px;
      line-height: 1.6;
    }

    @media (max-width: 768px) {
      h1 { font-size: 2.5rem; }
      .player-box { width: 45%; margin: 0.5rem; }
      .players-info { justify-content: center; }
      button { font-size: 1.2rem; padding: 0.8rem 1.5rem; }
    }
  </style>
</head>
<body>
  <!-- MENU SCREEN -->
  <div id="menu-screen" class="screen active">
    <h1>AXOLOTL PANIC<br>DELUXE EDITION</h1>
    <button id="play-btn" class="btn-pink">JUGAR</button>
    <button id="tutorial-btn" class="btn-cyan">TUTORIAL</button>
    <button id="credits-btn" class="btn-yellow">CR√âDITOS</button>
    <button id="exit-btn-menu" class="btn-purple">SALIR</button>
  </div>

  <!-- TUTORIAL SCREEN -->
  <div id="tutorial-screen" class="screen">
    <h1>TUTORIAL</h1>
    <div class="text-content" id="tutorial-text">
      <p><strong>¬°Bienvenido a AXOLOTL PANIC!</strong></p>
      <p>Tu objetivo es ganar la mayor cantidad de <strong>puntos</strong> pescando fichas de ajolotes y comprando objetos en <strong>La Tiendita</strong>.</p>
      <p>Cada turno puedes:</p>
      <ul>
        <li><strong>Recoger una carta</strong> y aplicarla o almacenarla (m√°x 5).</li>
        <li><strong>Usar una carta almacenada</strong> haciendo clic en ella.</li>
        <li><strong>Ir a La Tiendita</strong> para gastar basura en puntos.</li>
      </ul>
      <p>Las cartas te dan basura, roban a rivales, pescan fichas o activan eventos.</p>
      <p>¬°Tienes 8 segundos por turno! Si no act√∫as, pierdes el turno.</p>
      <p>El juego termina tras 30 turnos o cuando se acaben las 12 fichas.</p>
      <p><strong>¬°Divi√©rtete y s√© estrat√©gico!</strong></p>
    </div>
    <button id="back-tutorial" class="btn-pink">VOLVER</button>
  </div>

  <!-- CREDITS SCREEN -->
  <div id="credits-screen" class="screen">
    <h1>CR√âDITOS</h1>
    <div class="text-content" id="credits-text">
      <p><strong>Desarrollado por:</strong> Equipo Axolotl Panic</p>
      <p><strong>Dise√±o y Programaci√≥n:</strong> Grok 4 (xAI)</p>
      <p><strong>Arte Conceptual:</strong> Inspirado en ajolotes adorables</p>
      <p><strong>M√∫sica y SFX:</strong> Silencio ambiental (¬°es un juego web!)</p>
      <p><strong>Agradecimientos:</strong> A todos los ajolotes del mundo</p>
      <p>¬© 2025 AXOLOTL PANIC DELUXE EDITION - Todos los derechos reservados</p>
    </div>
    <button id="back-credits" class="btn-pink">VOLVER</button>
  </div>

  <!-- GAME SCREEN -->
  <div id="game-screen" class="screen">
    <button class="exit-btn" id="exit-to-menu">Salir al Men√∫</button>
    
    <div class="players-info" id="players-info"></div>
    
    <div class="turn-indicator" id="turn-indicator">Turno de: <span id="current-player-name">Tu</span></div>
    
    <div class="action-buttons" id="action-buttons"></div>
    
    <div class="stored-cards" id="stored-cards-area">
      <h3>Cartas Almacenadas (Haz clic para usar):</h3>
      <div id="stored-cards-list"></div>
    </div>
    
    <div class="tokens-area">
      <h3>Fichas de Ajolotes</h3>
      <div class="tokens" id="tokens"></div>
    </div>
  </div>

  <!-- RANKING SCREEN -->
  <div id="ranking-screen" class="screen">
    <h1>¬°JUEGO TERMINADO!</h1>
    <div class="ranking-list" id="ranking-list"></div>
    <button id="back-to-menu" class="btn-pink">Volver al Men√∫</button>
  </div>

  <!-- MODALS -->
  <div id="shop-modal" class="modal">
    <div class="modal-content">
      <h2>üõçÔ∏è La Tiendita</h2>
      <div id="shop-items"></div>
      <div class="modal-actions">
        <button id="close-shop" class="btn-pink">Salir</button>
      </div>
    </div>
  </div>

  <div id="fish-modal" class="modal">
    <div class="modal-content">
      <h2>üé£ Hora de Pescar</h2>
      <p>Elige una ficha para revelar su valor:</p>
      <div id="fish-tokens"></div>
      <div class="modal-actions">
        <button id="confirm-fish" class="btn-cyan" disabled>Aceptar</button>
        <button id="cancel-fish" class="btn-purple">Cancelar</button>
      </div>
    </div>
  </div>

  <div id="target-modal" class="modal">
    <div class="modal-content">
      <h2 id="target-title">Elige un rival:</h2>
      <div id="target-players"></div>
      <div class="modal-actions">
        <button id="cancel-target" class="btn-purple">Cancelar</button>
      </div>
    </div>
  </div>

  <!-- MESSAGE -->
  <div id="game-message" class="message"></div>

  <script>
    // === ESTADO DEL JUEGO ===
    const state = {
      currentScreen: 'menu',
      players: [
        { name: 'Tu', isHuman: true, trash: 0, score: 0, tokens: [], cards: [], skippedTurn: false },
        { name: 'Bot 1', isHuman: false, trash: 0, score: 0, tokens: [], cards: [], skippedTurn: false },
        { name: 'Bot 2', isHuman: false, trash: 0, score: 0, tokens: [], cards: [], skippedTurn: false },
        { name: 'Bot 3', isHuman: false, trash: 0, score: 0, tokens: [], cards: [], skippedTurn: false }
      ],
      currentPlayerIndex: 0,
      turnCount: 0,
      maxTurns: 30,
      deck: [],
      tokens: Array(12).fill().map((_, i) => ({
        id: i,
        value: i < 4 ? 0.5 : i < 8 ? 1 : 1.5,
        color: i < 4 ? 'pink' : i < 8 ? 'brown' : 'yellow',
        revealed: false,
        owner: null
      })),
      newCard: null,
      turnTimer: null,
      botTimer: null,
      reverseTurn: false
    };

    // === CARTAS ===
    const cardTypes = [
      { name: 'Basura +1', type: 'trash', value: 1 },
      { name: 'Basura +2', type: 'trash', value: 2 },
      { name: 'Basura +3', type: 'trash', value: 3 },
      { name: 'Robo-Basura', type: 'steal' },
      { name: 'Hora de Pescar', type: 'fish' },
      { name: 'Intercambio de Ajolotes', type: 'swap' },
      { name: 'Duelo de Perder Turno', type: 'skip' },
      { name: 'Rotaci√≥n de Basura', type: 'rotate' },
      { name: 'Cambio de Rotaci√≥n de Turnos', type: 'reverse' }
    ];

    function createDeck() {
      const deck = [];
      // 6 de cada basura
      for (let i = 0; i < 6; i++) {
        deck.push({ ...cardTypes[0] });
        deck.push({ ...cardTypes[1] });
        deck.push({ ...cardTypes[2] });
      }
      // 3 de cada especial
      for (let i = 3; i < cardTypes.length; i++) {
        for (let j = 0; j < 3; j++) {
          deck.push({ ...cardTypes[i] });
        }
      }
      return shuffle(deck);
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // === TIENDA ===
    const shopItems = [
      { name: 'Alguita Limpia', cost: 2, points: 1 },
      { name: 'Red Salvavidas', cost: 5, points: 2 },
      { name: 'Tanque de Ox√≠geno', cost: 10, points: 4 }
    ];

    // === NAVEGACI√ìN ENTRE PANTALLAS ===
    const screens = {
      menu: document.getElementById('menu-screen'),
      tutorial: document.getElementById('tutorial-screen'),
      credits: document.getElementById('credits-screen'),
      game: document.getElementById('game-screen'),
      ranking: document.getElementById('ranking-screen')
    };

    function showScreen(id) {
      Object.values(screens).forEach(s => s.classList.remove('active'));
      screens[id].classList.add('active');
      state.currentScreen = id;
    }

    // === EVENTOS DEL MEN√ö ===
    document.getElementById('play-btn').onclick = () => startGame();
    document.getElementById('tutorial-btn').onclick = () => showScreen('tutorial');
    document.getElementById('credits-btn').onclick = () => showScreen('credits');
    document.getElementById('exit-btn-menu').onclick = () => {
      if (confirm('¬øSeguro que quieres salir?')) window.close();
    };
    document.getElementById('back-tutorial').onclick = () => showScreen('menu');
    document.getElementById('back-credits').onclick = () => showScreen('menu');
    document.getElementById('exit-to-menu').onclick = () => {
      if (confirm('¬øVolver al men√∫? Se perder√° la partida.')) {
        showScreen('menu');
        resetGame();
      }
    };
    document.getElementById('back-to-menu').onclick = () => {
      showScreen('menu');
      resetGame();
    };

    // === INICIO DEL JUEGO ===
    function startGame() {
      resetGame();
      state.deck = createDeck();
      showScreen('game');
      updatePlayersUI();
      updateTokensUI();
      startTurn();
    }

    function resetGame() {
      state.currentPlayerIndex = 0;
      state.turnCount = 0;
      state.reverseTurn = false;
      state.players.forEach(p => {
        p.trash = 0;
        p.score = 0;
        p.tokens = [];
        p.cards = [];
        p.skippedTurn = false;
      });
      state.tokens.forEach(t => {
        t.revealed = false;
        t.owner = null;
      });
      state.newCard = null;
      clearTimeout(state.turnTimer);
      clearTimeout(state.botTimer);
    }

    // === UI ===
    function updatePlayersUI() {
      const container = document.getElementById('players-info');
      container.innerHTML = '';
      state.players.forEach((p, i) => {
        const box = document.createElement('div');
        box.className = `player-box ${p.isHuman ? 'human' : ''} ${i === state.currentPlayerIndex ? 'active' : ''}`;
        if (p.skippedTurn) box.style.opacity = '0.6';
        box.innerHTML = `
          <h3>${p.name}</h3>
          <p>Basura: ${p.trash}</p>
          <p>Puntaje: ${p.score}</p>
          <p>Fichas: ${p.tokens.map(t => t === 0.5 ? '0.5' : t).join(', ') || 'ninguna'}</p>
          <p>Cartas: ${p.cards.length}</p>
        `;
        container.appendChild(box);
      });
    }

    function updateTurnIndicator() {
      const player = state.players[state.currentPlayerIndex];
      document.getElementById('current-player-name').textContent = player.name;
      document.getElementById('turn-indicator').textContent = `Turno de: ${player.name}`;
    }

    function updateActionButtons() {
      const container = document.getElementById('action-buttons');
      container.innerHTML = '';
      const player = state.players[state.currentPlayerIndex];

      if (!player.isHuman) return;

      if (player.skippedTurn) {
        const btn = document.createElement('button');
        btn.textContent = 'Turno perdido...';
        btn.disabled = true;
        btn.className = 'btn-purple';
        container.appendChild(btn);
        return;
      }

      // Bot√≥n tienda siempre visible
      const shopBtn = document.createElement('button');
      shopBtn.textContent = 'Ir a La Tiendita';
      shopBtn.className = 'btn-yellow';
      shopBtn.onclick = openShop;
      container.appendChild(shopBtn);

      // Si no hay carta nueva
      if (!state.newCard && !player.cards.some(c => c)) {
        const drawBtn = document.createElement('button');
        drawBtn.textContent = 'Recoger Carta Nueva';
        drawBtn.className = 'btn-cyan';
        drawBtn.onclick = drawCard;
        container.appendChild(drawBtn);
      }

      // Si hay carta nueva
      if (state.newCard) {
        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Aplicar Carta Nueva';
        applyBtn.className = 'btn-pink';
        applyBtn.onclick = () => applyCard(state.newCard, true);
        container.appendChild(applyBtn);

        const storeBtn = document.createElement('button');
        storeBtn.textContent = 'Almacenar Carta Nueva';
        storeBtn.className = 'btn-purple';
        storeBtn.disabled = player.cards.length >= 5;
        storeBtn.onclick = storeNewCard;
        container.appendChild(storeBtn);
      }

      // Finalizar turno
      if (state.newCard || player.cards.length > 0) {
        const endBtn = document.createElement('button');
        endBtn.textContent = 'Finalizar Turno';
        endBtn.className = 'btn-pink';
        endBtn.onclick = endTurn;
        container.appendChild(endBtn);
      }
    }

    function updateStoredCards() {
      const list = document.getElementById('stored-cards-list');
      list.innerHTML = '';
      const player = state.players[state.currentPlayerIndex];
      if (!player.isHuman) return;

      player.cards.forEach((card, i) => {
        const tag = document.createElement('div');
        tag.className = 'card-tag';
        tag.textContent = card.name;
        tag.onclick = () => applyStoredCard(i);
        list.appendChild(tag);
      });
    }

    function updateTokensUI() {
      const container = document.getElementById('tokens');
      container.innerHTML = '';
      state.tokens.forEach(token => {
        const div = document.createElement('div');
        div.className = `token ${token.revealed ? 'revealed ' + token.color : ''} ${token.owner ? 'removed' : ''}`;
        container.appendChild(div);
      });
    }

    // === TURNO ===
    function startTurn() {
      const player = state.players[state.currentPlayerIndex];
      player.skippedTurn = false;
      updatePlayersUI();
      updateTurnIndicator();
      updateStoredCards();
      updateActionButtons();

      if (!player.isHuman) {
        state.botTimer = setTimeout(botPlay, 5000);
      } else {
        state.turnTimer = setTimeout(() => {
          showMessage('¬°Perdiste tu turno por inactividad!');
          endTurn();
        }, 8000);
      }
    }

    function endTurn() {
      clearTimeout(state.turnTimer);
      clearTimeout(state.botTimer);
      state.newCard = null;
      state.turnCount++;

      if (checkGameEnd()) return;

      // Avanzar turno
      do {
        state.currentPlayerIndex = state.reverseTurn
          ? (state.currentPlayerIndex - 1 + 4) % 4
          : (state.currentPlayerIndex + 1) % 4;
      } while (state.players[state.currentPlayerIndex].skippedTurn);

      startTurn();
    }

    function checkGameEnd() {
      const tokensLeft = state.tokens.filter(t => !t.owner).length;
      if (tokensLeft === 0 || state.turnCount >= state.maxTurns) {
        endGame();
        return true;
      }
      return false;
    }

    function endGame() {
      const sorted = [...state.players].sort((a, b) => b.score - a.score);
      const list = document.getElementById('ranking-list');
      list.innerHTML = '';
      sorted.forEach((p, i) => {
        const div = document.createElement('div');
        div.textContent = `${i + 1}. ${p.name} ‚Äî ${p.score} puntos`;
        if (i === 0) div.className = 'winner';
        list.appendChild(div);
      });
      showScreen('ranking');
    }

    // === ACCIONES ===
    function drawCard() {
      clearTimeout(state.turnTimer);
      if (state.deck.length === 0) state.deck = createDeck();
      state.newCard = state.deck.pop();
      showMessage(`Sacaste: ${state.newCard.name}`);
      updateActionButtons();
    }

    function storeNewCard() {
      const player = state.players[state.currentPlayerIndex];
      if (player.cards.length >= 5) return;
      player.cards.push(state.newCard);
      state.newCard = null;
      updateStoredCards();
      updateActionButtons();
    }

    function applyStoredCard(index) {
      const player = state.players[state.currentPlayerIndex];
      if (!player.isHuman || index >= player.cards.length) return;
      clearTimeout(state.turnTimer);
      const card = player.cards.splice(index, 0)[0];
      applyCard(card, false);
      updateStoredCards();
    }

    function applyCard(card, isNew) {
      const player = state.players[state.currentPlayerIndex];
      if (isNew) state.newCard = null;

      switch (card.type) {
        case 'trash':
          player.trash += card.value;
          showMessage(`+${card.value} basura`);
          break;
        case 'steal':
          openTargetSelection('Robo-Basura', target => {
            const roll = rollDice();
            const targetPlayer = state.players[target];
            const stolen = Math.min(roll, targetPlayer.trash);
            targetPlayer.trash -= stolen;
            player.trash += stolen;
            showMessage(`¬°Robaste ${stolen} basura!`);
            updatePlayersUI();
          });
          break;
        case 'fish':
          openFishModal();
          return;
        case 'swap':
          openTargetSelection('Intercambio de Ajolotes', target => {
            const pRoll = rollDice();
            const tRoll = rollDice();
            if (pRoll > tRoll && state.players[target].tokens.length > 0) {
              const idx = Math.floor(Math.random() * state.players[target].tokens.length);
              const token = state.players[target].tokens.splice(idx, 1)[0];
              state.players[target].score -= token;
              player.tokens.push(token);
              player.score += token;
              showMessage(`¬°Intercambiaste una ficha +${token} puntos!`);
            } else {
              showMessage(pRoll > tRoll ? 'El rival no tiene fichas' : '¬°Perdiste el duelo!');
            }
            updatePlayersUI();
          });
          break;
        case 'skip':
          openTargetSelection('Duelo de Perder Turno', target => {
            const pRoll = rollDice();
            const tRoll = rollDice();
            if (pRoll > tRoll) {
              state.players[target].skippedTurn = true;
              showMessage('¬°Ganaste el duelo! Rival pierde turno.');
            } else {
              player.skippedTurn = true;
              showMessage('¬°Perdiste el duelo! Pierdes tu pr√≥ximo turno.');
            }
          });
          break;
        case 'rotate':
          const trashes = state.players.map(p => p.trash);
          state.players.forEach((p, i) => {
            p.trash = trashes[state.reverseTurn ? (i + 1) % 4 : (i - 1 + 4) % 4];
          });
          showMessage('¬°Basura rotada entre jugadores!');
          updatePlayersUI();
          break;
        case 'reverse':
          state.reverseTurn = !state.reverseTurn;
          showMessage(`¬°Orden de turnos ${state.reverseTurn ? 'invertido' : 'normalizado'}!`);
          break;
      }

      if (isNew || !card.type.includes('modal')) {
        setTimeout(endTurn, 1500);
      }
    }

    // === MODALES ===
    function openShop() {
      clearTimeout(state.turnTimer);
      const modal = document.getElementById('shop-modal');
      const items = document.getElementById('shop-items');
      items.innerHTML = '';
      const player = state.players[0]; // humano

      shopItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shop-item';
        div.innerHTML = `
          <div>
            <strong>${item.name}</strong><br>
            Costo: ${item.cost} basura | +${item.points} puntos
          </div>
          <button class="btn-cyan" ${player.trash < item.cost ? 'disabled' : ''}>
            Comprar
          </button>
        `;
        div.querySelector('button').onclick = () => {
          player.trash -= item.cost;
          player.score += item.points;
          showMessage(`¬°Compraste ${item.name}! +${item.points} puntos`);
          updatePlayersUI();
          modal.classList.remove('active');
          endTurn();
        };
        items.appendChild(div);
      });

      modal.classList.add('active');
      document.getElementById('close-shop').onclick = () => {
        modal.classList.remove('active');
        endTurn();
      };
    }

    function openFishModal() {
      const modal = document.getElementById('fish-modal');
      const tokensDiv = document.getElementById('fish-tokens');
      tokensDiv.innerHTML = '';
      let selected = null;

      state.tokens.filter(t => !t.owner).forEach(token => {
        const div = document.createElement('div');
        div.className = 'fish-token';
        div.innerHTML = '<div class="token" style="margin:0 auto;"></div>';
        div.onclick = () => {
          document.querySelectorAll('.fish-token').forEach(d => d.classList.remove('selected'));
          div.classList.add('selected');
          selected = token;
          document.getElementById('confirm-fish').disabled = false;
        };
        tokensDiv.appendChild(div);
      });

      document.getElementById('confirm-fish').onclick = () => {
        if (!selected) return;
        selected.revealed = true;
        selected.owner = state.currentPlayerIndex;
        const player = state.players[state.currentPlayerIndex];
        player.tokens.push(selected.value);
        player.score += selected.value;
        showMessage(`¬°Pescaste una ficha ${selected.color === 'pink' ? 'rosa' : selected.color === 'brown' ? 'caf√©' : 'amarilla'} +${selected.value} puntos!`);
        updateTokensUI();
        updatePlayersUI();
        modal.classList.remove('active');
        endTurn();
      };

      document.getElementById('cancel-fish').onclick = () => {
        modal.classList.remove('active');
        endTurn();
      };

      modal.classList.add('active');
    }

    function openTargetSelection(title, callback) {
      const modal = document.getElementById('target-modal');
      document.getElementById('target-title').textContent = title;
      const playersDiv = document.getElementById('target-players');
      playersDiv.innerHTML = '';

      state.players.forEach((p, i) => {
        if (i === state.currentPlayerIndex) return;
        const btn = document.createElement('button');
        btn.textContent = p.name;
        btn.className = 'btn-purple';
        btn.style.margin = '0.5rem';
        btn.onclick = () => {
          modal.classList.remove('active');
          callback(i);
          setTimeout(endTurn, 1500);
        };
        playersDiv.appendChild(btn);
      });

      document.getElementById('cancel-target').onclick = () => {
        modal.classList.remove('active');
        endTurn();
      };

      modal.classList.add('active');
    }

    // === BOT ===
    function botPlay() {
      const bot = state.players[state.currentPlayerIndex];
      const human = state.players[0];
      const leader = state.players.reduce((a, b) => b.score > a.score ? b : a);

      // Estrategia simple
      let action = 'draw';

      if (bot.cards.length >= 5) {
        action = 'apply_old';
      } else if (bot.trash >= 10 && bot.score < human.score - 3) {
        action = 'shop';
      } else if (bot.cards.some(c => c.type === 'fish' || c.type === 'steal') && bot.score < leader.score) {
        action = 'apply_special';
      }

      switch (action) {
        case 'shop':
          const item = shopItems.find(i => i.cost <= bot.trash && i.points >= 2) || shopItems[0];
          if (bot.trash >= item.cost) {
            bot.trash -= item.cost;
            bot.score += item.points;
            showMessage(`${bot.name} compr√≥ ${item.name}`);
          } else {
            action = 'draw';
          }
          break;
        case 'apply_old':
          const idx = bot.cards.findIndex(c => c.type === 'trash');
          if (idx !== -1) {
            const card = bot.cards.splice(idx, 1)[0];
            bot.trash += card.value;
          }
          break;
        case 'apply_special':
          const specialIdx = bot.cards.findIndex(c => c.type === 'steal' || c.type === 'fish');
          if (specialIdx !== -1) {
            const card = bot.cards.splice(specialIdx, 1)[0];
            applyCardBot(card);
            return;
          }
          break;
      }

      if (action === 'draw' || action === 'apply_old') {
        if (state.deck.length === 0) state.deck = createDeck();
        const card = state.deck.pop();
        if (bot.cards.length < 4 && Math.random() > 0.3) {
          bot.cards.push(card);
        } else {
          // aplicar
          if (card.type === 'trash') {
            bot.trash += card.value;
          } else if (card.type === 'fish' && state.tokens.some(t => !t.owner)) {
            const avail = state.tokens.filter(t => !t.owner);
            const best = avail.sort((a,b) => b.value - a.value)[0];
            best.owner = state.currentPlayerIndex;
            best.revealed = true;
            bot.tokens.push(best.value);
            bot.score += best.value;
            updateTokensUI();
          }
        }
      }

      showMessage(`${bot.name} ha hecho su jugada`);
      updatePlayersUI();
      setTimeout(endTurn, 2000);
    }

    function applyCardBot(card) {
      const bot = state.players[state.currentPlayerIndex];
      let target = state.players.indexOf(state.players.reduce((a,b) => b.score > a.score ? b : a));
      if (target === state.currentPlayerIndex) target = (target + 1) % 4;

      switch (card.type) {
        case 'steal':
          const roll = rollDice();
          const stolen = Math.min(roll, state.players[target].trash);
          state.players[target].trash -= stolen;
          bot.trash += stolen;
          break;
        case 'fish':
          const avail = state.tokens.filter(t => !t.owner);
          if (avail.length > 0) {
            const best = avail.sort((a,b) => b.value - a.value)[0];
            best.owner = state.currentPlayerIndex;
            best.revealed = true;
            bot.tokens.push(best.value);
            bot.score += best.value;
            updateTokensUI();
          }
          break;
      }
      updatePlayersUI();
      setTimeout(endTurn, 2000);
    }

    // === UTILS ===
    function rollDice() {
      return Math.floor(Math.random() * 6) + 1;
    }

    function showMessage(text) {
      const msg = document.getElementById('game-message');
      msg.textContent = text;
      msg.classList.add('show');
      setTimeout(() => msg.classList.remove('show'), 2500);
    }

    // Inicializar
    updateTokensUI();
  </script>
</body>
</html>